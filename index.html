<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>トルポ -ToRuPose-</title>
    <link rel="stylesheet" href="style.css">

    <!-- MediaPipe Tasks Vision (Loaded dynamically) -->
    <style>
        /* Hide video element since we draw to canvas */
        #input-video {
            display: none;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <video id="input-video" playsinline style="display: none;"></video>
        <canvas id="output-canvas"></canvas>

        <!-- UI Overlay -->
        <div id="ui-layer">
            <div id="start-screen" class="screen">
                <h1>トルポ</h1>
                <h2 id="mode-display">MODE: FREE</h2>
                <p>Press 'M' to Toggle Mode</p>
                <p>Press 'S' to START</p>
                <p id="settings-hint">Press 'P' for SETTINGS</p>
            </div>

            <div id="settings-screen" class="screen hidden">
                <h2>FREE MODE SETTINGS</h2>
                <div id="settings-list"></div>
                <p>Press 1-4 to Change | 'B' Back</p>
            </div>

            <div id="story-config-screen" class="screen hidden">
                <h2>STORY LEVEL EDITOR</h2>
                <div id="stage-selector">
                    <span id="stage-display">&lt; Stage 1 &gt;</span>
                </div>
                <p class="hint">(Use ',' and '.' to Change Stage)</p>
                <div id="story-settings-list"></div>
                <p>Press 1-4 to Cycle Options</p>
                <p>Press 'B' to Back</p>
            </div>

            <div id="hud" class="hidden">
                <div id="score">Score: 0</div>
                <div id="time">Time: 60</div>
                <div id="stage-info" class="hidden">Stage: 1/5</div>
                <div id="target-info" class="hidden">Target: 0</div>
            </div>

            <div id="game-over-screen" class="screen hidden">
                <h1 id="go-title">GAME OVER</h1>
                <h2 id="final-score">Final Score: 0</h2>
                <div id="go-story-info" class="hidden"></div>
                <p>Press 'R' to Restart</p>
                <p>Press 'P' for Settings</p>
                <div
                    style="margin-top:20px; font-size:0.8rem; color:#aaa; border-top:1px solid #555; padding-top:10px;">
                    <p>ℹ️ 品質改善: プレイ中のキー操作ログ等を匿名で収集しています。</p>
                </div>
            </div>

            <div id="stage-clear-screen" class="screen hidden">
                <h1 id="sc-title">STAGE CLEARED!</h1>
                <p>Get Ready for Next Stage...</p>
            </div>
        </div>

        <!-- GESTURE BUTTON (Floating above screens) -->
        <div id="gesture-btn" class="hidden">
            <svg viewBox="0 0 100 100" width="100%" height="100%">
                <circle cx="50" cy="50" r="45" stroke="rgba(255,255,255,0.8)" stroke-width="4"
                    fill="rgba(0,255,255,0.2)" />
                <path id="gesture-progress-path" d="" fill="none" stroke="#ffff00" stroke-width="6"
                    stroke-linecap="round" />
                <text x="50" y="45" text-anchor="middle" fill="white" font-size="14" font-weight="bold"
                    style="text-shadow: 1px 1px 2px black;">両手タッチ</text>
                <text x="50" y="65" text-anchor="middle" fill="#ffff00" font-size="12" font-weight="bold"
                    style="text-shadow: 1px 1px 2px black;">START</text>
            </svg>
        </div>
    </div>
    </div>

    <style>
        #gesture-btn {
            position: absolute;
            top: 25%;
            left: 85%;
            width: 140px;
            height: 140px;
            transform: translate(-50%, -50%);
            z-index: 1000;
            /* Above everything */
            pointer-events: none;
            transition: transform 0.1s;
        }

        #gesture-btn.active-pulse {
            transform: translate(-50%, -50%) scale(1.1);
            filter: drop-shadow(0 0 15px #00ffff);
        }
    </style>

    <script>
        // --- PoC Logging (Web Port) ---
        const GAS_URL = "https://script.google.com/macros/s/AKfycbxeJqv6X1k6V3o9HkMGSe7I-Td0F0ry8MgN3_NtLkEn1aYfapXYND5nUYl8PCamvu8ANA/exec";
        const GAME_NAME = "BodyCatch_Web_v1";
        const SESSION_ID = "sesscatch_" + Math.random().toString(36).substr(2, 9);

        // Send Log (Generic)
        window.sendLog = function (data) {
            console.log(`[PoC Log]`, data);

            // Mapper
            let logKey = "";
            let logNote = "";

            if (data.type === 'key') {
                logKey = data.key;
                logNote = data.note || "";
            } else if (data.type === 'erroneous_input') {
                logKey = data.key;
                logNote = `ERRONEOUS (Exp: ${data.expected ? data.expected.join(',') : '?'})`;
            } else if (data.type === 'game_over') {
                logKey = "GAME_OVER";
                logNote = `Stage: ${data.stage || '-'}, Score: ${data.score}, Retry: ${data.retryCount}, Mode: ${data.mode}`;
            } else if (data.type === 'stage_clear') {
                logKey = "STAGE_CLEAR";
                logNote = `Stage: ${data.stage}, Score: ${data.score}, Retry: ${data.retryCount}`;
            } else {
                logKey = data.type || "UNKNOWN";
                logNote = JSON.stringify(data);
            }

            const payload = {
                gameName: GAME_NAME,
                session: SESSION_ID,
                timestamp: new Date().toISOString(),
                key: logKey,
                note: logNote
            };

            fetch(GAS_URL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify(payload)
            }).catch(e => console.error("Log Error:", e));
        }

        // Backward compatibility
        function sendKeyLog(keyName, note = "") {
            window.sendLog({ type: 'key', key: keyName, note: note });
        }

        // Global Key Listener for Logging
        window.addEventListener('keydown', (e) => {
            sendKeyLog(e.key);
        });
    </script>
    <script type="module">

        const canvas = document.getElementById('output-canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('input-video');

        // Screens
        const screens = {
            start: document.getElementById('start-screen'),
            settings: document.getElementById('settings-screen'),
            storyConfig: document.getElementById('story-config-screen'),
            hud: document.getElementById('hud'),
            gameOver: document.getElementById('game-over-screen'),
            stageClear: document.getElementById('stage-clear-screen')
        };

        // UI Elements
        const els = {
            score: document.getElementById('score'),
            time: document.getElementById('time'),
            modeDisplay: document.getElementById('mode-display'),
            settingsList: document.getElementById('settings-list'),
            storySettingsList: document.getElementById('story-settings-list'),
            stageSelector: document.getElementById('stage-display'),
            stageInfo: document.getElementById('stage-info'),
            targetInfo: document.getElementById('target-info'),
            finalScore: document.getElementById('final-score'),
            goStoryInfo: document.getElementById('go-story-info'),
            gestureBtn: document.getElementById('gesture-btn'),
            gestureProgressPath: document.getElementById('gesture-progress-path')
        };

        // Assets
        const assets = {
            music: new Audio('assets/techno.mp3'),
            fruitImages: [] // Will be populated dynamically
        };
        assets.music.loop = true;

        // Config: Dynamically loaded from server
        let AVAILABLE_IMAGES = [];

        async function initFruitImages() {
            try {
                // Fetch list from server
                const response = await fetch('/api/icons');
                if (response.ok) {
                    const files = await response.json();
                    AVAILABLE_IMAGES = files;
                    console.log("Loaded images from server:", files);
                } else {
                    console.warn("Failed to load image list from server, using defaults.");
                    AVAILABLE_IMAGES = ['banana.png', 'orange.png'];
                }
            } catch (e) {
                console.error("Error fetching icons:", e);
                AVAILABLE_IMAGES = ['banana.png', 'orange.png'];
            }

            // Shuffle and pick max 5
            const shuffled = [...AVAILABLE_IMAGES].sort(() => 0.5 - Math.random());
            const selected = shuffled.slice(0, 5); // Pick up to 5

            assets.fruitImages = selected.map(filename => {
                const img = new Image();
                img.src = `assets/icon/${filename}`;
                return img;
            });
            console.log(`Selected ${assets.fruitImages.length} fruit images:`, selected);
        }
        // Call immediately
        initFruitImages();

        // Game Constants
        const MODES = { FREE: 'FREE', STORY: 'STORY', TEST: 'TEST' };

        // Helpers
        function randRange(min, max) { return Math.random() * (max - min) + min; }
        function randInt(min, max) { return Math.floor(randRange(min, max)); }

        class Fruit {
            constructor(w, h, speedMult, direction, isStatic = false, staticX = 0, staticY = 0) {
                // Select random image from the active pool
                if (assets.fruitImages.length > 0) {
                    this.img = assets.fruitImages[randInt(0, assets.fruitImages.length)];
                } else {
                    this.img = null; // Fallback
                }

                this.radius = 30;
                this.w = w;
                this.h = h;
                this.direction = direction;
                this.isStatic = isStatic;

                if (this.isStatic) {
                    this.x = staticX;
                    this.y = staticY;
                    this.speed = 0;
                    this.dx = 0;
                } else {
                    const baseSpeed = randRange(5, 10);
                    this.speed = baseSpeed * speedMult;

                    if (direction === 'Up') {
                        this.x = randInt(50, w - 50);
                        this.y = h + 50;
                    } else if (direction === 'Diagonal') {
                        this.x = randInt(50, w - 50);
                        this.y = -50;
                        this.dx = (Math.random() < 0.5 ? -1 : 1) * (this.speed * 0.5);
                    } else { // Down
                        this.x = randInt(50, w - 50);
                        this.y = -50;
                    }
                }
            }

            update() {
                if (this.isStatic) return;

                if (this.direction === 'Up') {
                    this.y -= this.speed;
                } else if (this.direction === 'Diagonal') {
                    this.y += this.speed;
                    this.x += this.dx;
                    if (this.x < 0 || this.x > this.w) this.dx *= -1;
                } else {
                    this.y += this.speed;
                }
            }

            draw(ctx) {
                if (this.img && this.img.complete && this.img.naturalHeight !== 0) {
                    const size = 120;
                    ctx.drawImage(this.img, this.x - size / 2, this.y - size / 2, size, size);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'orange'; // Generic Fallback
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        class Game {
            constructor() {
                this.state = 'START';
                this.mode = MODES.STORY;
                this.frameCount = 0; // For Heartbeat

                this.freeSettings = {
                    duration: { options: [30, 60, 90, 120], idx: 1, label: 'Game Duration (s)' },
                    spawn_rate: { options: [1.5, 1.0, 0.5, 0.3], idx: 1, label: 'Spawn Rate (s)' },
                    speed_mult: { options: [0.5, 1.0, 1.5, 2.0], idx: 1, label: 'Fall Speed' },
                    direction: { options: ['Down', 'Diagonal', 'Up'], idx: 0, label: 'Direction' }
                };

                this.storyConfig = [
                    { duration: 30, spawn_rate: 1.5, speed_mult: 0.5, direction: 'Down' },
                    { duration: 45, spawn_rate: 1.0, speed_mult: 1.0, direction: 'Down' },
                    { duration: 60, spawn_rate: 1.0, speed_mult: 1.5, direction: 'Diagonal' },
                    { duration: 60, spawn_rate: 0.5, speed_mult: 1.5, direction: 'Diagonal' },
                    { duration: 90, spawn_rate: 0.3, speed_mult: 2.0, direction: 'Up' }
                ];
                this.storyOptions = {
                    duration: [30, 45, 60, 90, 120],
                    spawn_rate: [2.0, 1.5, 1.0, 0.5, 0.3],
                    speed_mult: [0.5, 1.0, 1.5, 2.0, 3.0],
                    direction: ['Down', 'Diagonal', 'Up']
                };

                this.currentStage = 0;
                this.score = 0;
                this.startTime = 0;
                this.fruits = [];
                this.effects = [];
                this.lastSpawnTime = 0;
                this.retryCount = 0;

                // Gesture Start Config
                this.gestureProgress = 0;
                this.gestureMax = 60; // Frames (approx 1-2 sec)

                this.inputHandling();
                this.updateUI();
            }

            inputHandling() {
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    let valid = false;
                    let expected = [];

                    // Global Keys
                    if (['q', 'escape'].includes(key)) valid = true;

                    // State-specific validation
                    if (this.state === 'START') {
                        expected = ['s', 'p', 'm', 't', 'q', 'escape'];
                        if (expected.includes(key)) valid = true;
                    } else if (this.state === 'SETTINGS') {
                        expected = ['1', '2', '3', '4', 'b', 'p', 'q', 'escape'];
                        if (expected.includes(key)) valid = true;
                    } else if (this.state === 'STORY_CONFIG') {
                        expected = ['1', '2', '3', '4', 'b', 'p', ',', '.', '<', '>', 'q', 'escape'];
                        if (expected.includes(key)) valid = true;
                    } else if (this.state === 'GAMEOVER') {
                        expected = ['r', 'p', 'q', 'escape'];
                        if (expected.includes(key)) valid = true;
                    } else if (this.state === 'PLAYING') {
                        expected = ['q', 'escape', 'd'];
                        if (expected.includes(key)) valid = true;
                    } else {
                        valid = false;
                    }

                    if (!valid) {
                        if (window.sendLog) window.sendLog({
                            type: 'erroneous_input',
                            key: key,
                            state: this.state,
                            expected: expected,
                            description: "User pressed unexpected key."
                        });
                        return;
                    }

                    // Normal Logic
                    if (window.sendKeyLog) window.sendKeyLog(key);

                    if (key === 'q' || key === 'escape') {
                        if (this.state === 'PLAYING') {
                            this.state = 'START';
                            this.stopMusic();
                        }
                    }

                    if (this.state === 'START') {
                        if (key === 's') this.startGame();
                        if (key === 'p') this.state = this.mode === MODES.FREE ? 'SETTINGS' : 'STORY_CONFIG';
                        if (key === 'm') {
                            this.mode = this.mode === MODES.FREE ? MODES.STORY : MODES.FREE;
                            document.body.className = this.mode === MODES.STORY ? 'mode-story' : '';
                        }
                        // TEST MODE TOGGLE
                        if (key === 't') {
                            this.mode = MODES.TEST;
                            this.startGame();
                        }
                    } else if (this.state === 'SETTINGS') {
                        if (key === 'b' || key === 'p') this.state = 'START';
                        if (['1', '2', '3', '4'].includes(key)) {
                            const keys = Object.keys(this.freeSettings);
                            const idx = parseInt(key) - 1;
                            if (idx < keys.length) {
                                const k = keys[idx];
                                const s = this.freeSettings[k];
                                s.idx = (s.idx + 1) % s.options.length;
                            }
                        }
                    } else if (this.state === 'STORY_CONFIG') {
                        if (key === 'b' || key === 'p') this.state = 'START';
                        if (key === ',' || key === '<') this.currentStage = Math.max(0, this.currentStage - 1);
                        if (key === '.' || key === '>') this.currentStage = Math.min(4, this.currentStage + 1);

                        const cfg = this.storyConfig[this.currentStage];
                        const opt = this.storyOptions;
                        if (key === '1') cfg.duration = this.nextOpt(opt.duration, cfg.duration);
                        if (key === '2') cfg.spawn_rate = this.nextOpt(opt.spawn_rate, cfg.spawn_rate);
                        if (key === '3') cfg.speed_mult = this.nextOpt(opt.speed_mult, cfg.speed_mult);
                        if (key === '4') cfg.direction = this.nextOpt(opt.direction, cfg.direction);

                    } else if (this.state === 'GAMEOVER') {
                        if (key === 'r') this.state === 'GAMEOVER' && this.restartGame();
                        if (key === 'p') this.state = this.mode === MODES.FREE ? 'SETTINGS' : 'STORY_CONFIG';
                    }

                    this.updateUI();
                });
            }

            nextOpt(arr, current) {
                const i = arr.indexOf(current);
                return arr[(i + 1) % arr.length];
            }

            startGame(restartStage = false) {
                this.score = 0;
                this.startTime = Date.now();
                this.fruits = [];
                this.effects = [];
                this.lastSpawnTime = 0;

                if (this.mode === MODES.STORY && !restartStage) {
                    if (this.state === 'START') {
                        this.currentStage = 0;
                        this.retryCount = 0;
                    }
                } else if (this.mode === MODES.TEST) {
                    // TEST MODE SETUP
                    this.gameDuration = 9999;
                    this.spawnRate = 9999;
                    this.speedMult = 0;
                    this.direction = 'Down';
                    this.targetScore = 1000;
                    this.retryCount = 0;

                    for (let i = 0; i < 10; i++) {
                        const x = (canvas.width / 11) * (i + 1);
                        const y = (i % 2 === 0) ? canvas.height * 0.3 : canvas.height * 0.5;
                        this.fruits.push(new Fruit(canvas.width, canvas.height, 0, 'Down', true, x, y));
                    }
                } else {
                    if (this.state === 'START') this.retryCount = 0;
                }

                // Apply Settings
                if (this.mode === MODES.FREE) {
                    const s = this.freeSettings;
                    this.gameDuration = s.duration.options[s.duration.idx];
                    this.spawnRate = s.spawn_rate.options[s.spawn_rate.idx];
                    this.speedMult = s.speed_mult.options[s.speed_mult.idx];
                    this.direction = s.direction.options[s.direction.idx];
                    this.targetScore = 0;
                } else if (this.mode === MODES.STORY) {
                    const cfg = this.storyConfig[this.currentStage];
                    this.gameDuration = cfg.duration;
                    this.spawnRate = cfg.spawn_rate;
                    this.speedMult = cfg.speed_mult;
                    this.direction = cfg.direction;

                    const totalDrops = this.gameDuration / this.spawnRate;
                    this.targetScore = Math.floor(totalDrops * 3 * 0.60);
                }

                this.state = 'PLAYING';
                this.playMusic();
                this.updateUI();
            }

            restartGame() {
                if (this.mode === MODES.STORY && this.score >= this.targetScore && this.currentStage === 4) {
                    this.currentStage = 0;
                    this.retryCount = 0;
                } else {
                    this.retryCount++;
                }
                this.startGame(true);
            }

            playMusic() {
                assets.music.currentTime = 0;
                assets.music.play().catch(e => console.log("Audio play failed (maybe need interaction):", e));
            }

            stopMusic() {
                assets.music.pause();
            }

            updateUI() {
                // Hide all
                Object.values(screens).forEach(s => s.classList.add('hidden'));

                if (this.state === 'START') {
                    screens.start.classList.remove('hidden');
                    els.modeDisplay.textContent = `MODE: ${this.mode}`;
                } else if (this.state === 'SETTINGS') {
                    screens.settings.classList.remove('hidden');
                    // Render list
                    let html = '';
                    Object.keys(this.freeSettings).forEach((k, i) => {
                        const item = this.freeSettings[k];
                        html += `<div class="setting-item">${i + 1}. ${item.label}: ${item.options[item.idx]}</div>`;
                    });
                    els.settingsList.innerHTML = html;
                } else if (this.state === 'STORY_CONFIG') {
                    screens.storyConfig.classList.remove('hidden');
                    els.stageSelector.textContent = `< Stage ${this.currentStage + 1} >`;
                    const cfg = this.storyConfig[this.currentStage];
                    let html = `
                <div class="setting-item">1. Duration: ${cfg.duration}s</div>
                <div class="setting-item">2. Spawn Rate: ${cfg.spawn_rate}s</div>
                <div class="setting-item">3. Speed Mult: ${cfg.speed_mult}x</div>
                <div class="setting-item">4. Direction: ${cfg.direction}</div>
            `;
                    els.storySettingsList.innerHTML = html;
                } else if (this.state === 'PLAYING') {
                    screens.hud.classList.remove('hidden');
                    if (this.mode === MODES.STORY) {
                        els.stageInfo.classList.remove('hidden');
                        els.stageInfo.textContent = `Stage: ${this.currentStage + 1}/5`;
                        els.targetInfo.classList.remove('hidden');
                        els.targetInfo.textContent = `Target: ${this.targetScore}`;
                    } else if (this.mode === MODES.TEST) {
                        els.stageInfo.classList.remove('hidden');
                        els.stageInfo.textContent = "TEST MODE";
                        els.targetInfo.classList.remove('hidden');
                        els.targetInfo.textContent = "Catch 10 items";
                    } else {
                        els.stageInfo.classList.add('hidden');
                        els.targetInfo.classList.add('hidden');
                    }
                } else if (this.state === 'GAMEOVER') {
                    screens.gameOver.classList.remove('hidden');
                    els.finalScore.textContent = `Final Score: ${this.score}`;

                    if (this.mode === MODES.STORY) {
                        els.goStoryInfo.classList.remove('hidden');
                        if (this.score >= this.targetScore && this.currentStage === 4) {
                            screens.gameOver.querySelector('h1').textContent = "ALL STAGES CLEARED!";
                            screens.gameOver.querySelector('h1').style.color = "#0f0";
                            els.goStoryInfo.textContent = "";
                        } else if (this.score < this.targetScore) {
                            screens.gameOver.querySelector('h1').textContent = "STAGE FAILED...";
                            screens.gameOver.querySelector('h1').style.color = "#f00";
                            els.goStoryInfo.textContent = `Target was: ${this.targetScore}`;
                        }
                    } else {
                        screens.gameOver.querySelector('h1').textContent = "GAME OVER";
                        screens.gameOver.querySelector('h1').style.color = "#f00";
                        els.goStoryInfo.classList.add('hidden');
                    }
                } else if (this.state === 'STAGE_CLEAR') {
                    screens.stageClear.classList.remove('hidden');
                    screens.stageClear.querySelector('h1').textContent = `STAGE ${this.currentStage} CLEARED!`;
                }
            }

            update(landmarks) {
                if (this.state !== 'PLAYING') return;

                const now = Date.now();
                const elapsed = (now - this.startTime) / 1000;
                const remaining = Math.max(0, this.gameDuration - elapsed);

                els.time.textContent = `Time: ${Math.floor(remaining)}`;
                els.score.textContent = `Score: ${this.score}`;
                els.time.classList.toggle('low-time', remaining <= 10);

                if (remaining <= 0) {
                    this.checkGameOver();
                    return;
                }

                if (now - this.lastSpawnTime > this.spawnRate * 1000) {
                    this.fruits.push(new Fruit(canvas.width, canvas.height, this.speedMult, this.direction));
                    this.lastSpawnTime = now;
                }

                // Collision & Logic
                // Interaction points: Nose(0), Wrists(15,16), Digits(19,20), Foot Indices(31,32)
                const relevantLandmarks = [
                    { idx: 0, pts: 3 }, // Head
                    { idx: 15, pts: 1 }, // L Wrist
                    { idx: 16, pts: 1 }, // R Wrist
                    { idx: 19, pts: 1 }, // L Index
                    { idx: 20, pts: 1 }, // R Index
                    { idx: 31, pts: 2 }, // L Foot
                    { idx: 32, pts: 2 }  // R Foot
                ];
                this.debugLandmarks = relevantLandmarks;

                for (let i = this.fruits.length - 1; i >= 0; i--) {
                    let f = this.fruits[i];
                    f.update();

                    let caught = false;
                    // Collision detection
                    if (landmarks) {
                        for (let lm of relevantLandmarks) {
                            const p = landmarks[lm.idx];
                            if (p) {
                                const px = p.x * canvas.width;
                                const py = p.y * canvas.height;
                                const dist = Math.hypot(px - f.x, py - f.y);

                                if (dist < 50 + f.radius) {
                                    caught = true;
                                    this.score += lm.pts;
                                    this.effects.push({ Rx: f.x, Ry: f.y, r: 10 });
                                    break;
                                }
                            }
                        }
                    }

                    let remove = caught;
                    if (!f.isStatic) {
                        if (f.direction === 'Up' && f.y < -50) remove = true;
                        if (f.direction !== 'Up' && f.y > canvas.height + 50) remove = true;
                    }

                    if (remove) {
                        this.fruits.splice(i, 1);
                    }
                }
            }

            draw(ctx, landmarks) {
                this.frameCount++;

                // Effects
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                for (let i = this.effects.length - 1; i >= 0; i--) {
                    let e = this.effects[i];
                    e.r += 5;
                    ctx.beginPath();
                    ctx.arc(e.Rx, e.Ry, e.r, 0, Math.PI * 2);
                    ctx.stroke();
                    if (e.r > 50) this.effects.splice(i, 1);
                }

                // Fruits
                this.fruits.forEach(f => f.draw(ctx));

                // Fruits
                this.fruits.forEach(f => f.draw(ctx));

                // Landmarks Drawing (Visual Validation)

                // Landmarks Drawing (Visual Validation)
                if (landmarks && this.state === 'PLAYING') {
                    const h = canvas.height;
                    const w = canvas.width;

                    const pts = [
                        { idx: 0, c: 'blue' },
                        { idx: 15, c: 'lime' }, { idx: 16, c: 'lime' },
                        { idx: 19, c: 'cyan' }, { idx: 20, c: 'cyan' },
                        { idx: 31, c: 'red' }, { idx: 32, c: 'red' }
                    ];

                    pts.forEach(p => {
                        const lm = landmarks[p.idx];
                        if (lm && lm.visibility > 0.1) {
                            const lx = lm.x * w;
                            const ly = lm.y * h;

                            // Hitbox
                            ctx.beginPath();
                            ctx.strokeStyle = "rgba(255, 255, 0, 0.5)";
                            ctx.lineWidth = 2;
                            ctx.arc(lx, ly, 50, 0, Math.PI * 2);
                            ctx.stroke();

                            // Dot
                            ctx.beginPath();
                            ctx.arc(lx, ly, 15, 0, Math.PI * 2);
                            ctx.fillStyle = p.c;
                            ctx.fill();
                        }
                    });
                }

                // DEBUG OVERLAY - MOVED OUTSIDE detection check
                if (this.state === 'PLAYING' && this.mode === MODES.TEST) {
                    const h = canvas.height;
                    const w = canvas.width;

                    let debugInfo = { handX: 0, handY: 0, fruitX: 0, fruitY: 0, dist: 9999, vis: 0 };
                    let activeHand = null;

                    if (landmarks) {
                        const pts = [
                            { idx: 0 }, { idx: 15 }, { idx: 16 }, { idx: 19 }, { idx: 20 }, { idx: 31 }, { idx: 32 }
                        ];

                        pts.forEach(p => {
                            const lm = landmarks[p.idx];
                            if (lm) {
                                const lx = lm.x * w;
                                const ly = lm.y * h;

                                this.fruits.forEach(f => {
                                    const d = Math.hypot(lx - f.x, ly - f.y);
                                    if (d < debugInfo.dist) {
                                        debugInfo.dist = d;
                                        debugInfo.handX = lx;
                                        debugInfo.handY = ly;
                                        debugInfo.fruitX = f.x;
                                        debugInfo.fruitY = f.y;
                                        // SAFELY ACCESS VISIBILITY (default 0)
                                        debugInfo.vis = (lm.visibility !== undefined) ? lm.visibility : 0;
                                        activeHand = p.idx;
                                    }
                                });
                            }
                        });
                    }

                    // Text Box (Bottom Left)
                    const boxX = 10;
                    const boxY = h - 220;

                    ctx.fillStyle = "rgba(0,0,0,0.7)";
                    ctx.fillRect(boxX, boxY, 320, 180);
                    ctx.fillStyle = "white";
                    ctx.font = "16px monospace";
                    ctx.fillText(`DEBUG MODE (Frame: ${this.frameCount})`, boxX + 10, boxY + 25);
                    ctx.fillText(`Canvas: ${w}x${h}`, boxX + 10, boxY + 45);

                    if (activeHand !== null) {
                        const names = { 0: 'Nose', 15: 'L.Wrist', 16: 'R.Wrist', 19: 'L.Index', 20: 'R.Index', 31: 'L.Foot', 32: 'R.Foot' };
                        const name = names[activeHand] || activeHand;

                        ctx.fillText(`Point:  ${name} (${activeHand})`, boxX + 10, boxY + 65);

                        // CRASH FIX: SAFE CHECK OR DEFAULT FOR TOFIXED
                        const visVal = (debugInfo.vis !== undefined) ? debugInfo.vis : 0;
                        ctx.fillText(`Vis:    ${visVal.toFixed(4)}`, boxX + 10, boxY + 85);

                        ctx.fillText(`Coord:  ${Math.floor(debugInfo.handX)}, ${Math.floor(debugInfo.handY)}`, boxX + 10, boxY + 105);
                        ctx.fillText(`Fruit:  ${Math.floor(debugInfo.fruitX)}, ${Math.floor(debugInfo.fruitY)}`, boxX + 10, boxY + 125);
                        ctx.fillText(`Dist:   ${Math.floor(debugInfo.dist)} (Req < 80)`, boxX + 10, boxY + 145);

                        ctx.fillStyle = debugInfo.dist < 80 ? "#0f0" : "#f00";
                        ctx.fillText(`Result: ${debugInfo.dist < 80 ? "HIT" : "MISS"}`, boxX + 10, boxY + 165);
                    } else {
                        ctx.fillText(`No active tracking points`, boxX + 10, boxY + 70);
                        if (!landmarks) {
                            ctx.fillText(`found. (Detection = NULL)`, boxX + 10, boxY + 90);
                        } else {
                            ctx.fillText(`found. (All points filtered?)`, boxX + 10, boxY + 90);
                        }
                    }
                }
            }

            checkGameOver() {
                this.stopMusic();
                if (this.mode === MODES.FREE) {
                    this.state = 'GAMEOVER';
                    this.updateUI();

                    if (window.sendLog) window.sendLog({
                        type: 'game_over',
                        mode: 'FREE',
                        score: this.score,
                        duration: this.gameDuration,
                        retryCount: this.retryCount
                    });

                } else if (this.mode === MODES.TEST) {
                    this.state = 'GAMEOVER';
                    this.updateUI();
                } else {
                    if (this.score >= this.targetScore) {
                        if (this.currentStage < 4) {
                            if (window.sendLog) window.sendLog({
                                type: 'stage_clear',
                                mode: 'STORY',
                                stage: this.currentStage + 1,
                                score: this.score,
                                target: this.targetScore,
                                retryCount: this.retryCount
                            });
                            this.retryCount = 0;

                            this.currentStage++;
                            this.state = 'STAGE_CLEAR';
                            this.updateUI();
                            setTimeout(() => {
                                if (this.state === 'STAGE_CLEAR') this.startGame(true);
                            }, 3000);
                        } else {
                            this.state = 'GAMEOVER';
                            this.updateUI();

                            if (window.sendLog) window.sendLog({
                                type: 'game_over',
                                mode: 'STORY',
                                result: 'ALL_CLEARED',
                                score: this.score,
                                finalStage: this.currentStage + 1,
                                retryCount: this.retryCount
                            });
                        }
                    } else {
                        this.state = 'GAMEOVER';
                        this.updateUI();

                        if (window.sendLog) window.sendLog({
                            type: 'game_over',
                            mode: 'STORY',
                            result: 'FAILED',
                            stage: this.currentStage + 1,
                            score: this.score,
                            target: this.targetScore,
                            retryCount: this.retryCount
                        });
                    }
                }
            }

            // --- GESTURE START LOGIC ---
            updateGestureLogic(landmarks) {
                // UI VISIBILITY
                if (this.state === 'START' || this.state === 'GAMEOVER') {
                    els.gestureBtn.classList.remove('hidden');
                    // Label Update
                    const label = els.gestureBtn.querySelector('text:last-of-type');
                    if (label) label.textContent = (this.state === 'START' ? "START" : "RETRY");
                } else {
                    els.gestureBtn.classList.add('hidden');
                    return;
                }

                if (!landmarks) return;

                // Button Position (Top Right)
                // CSS is Top 25%, Left 85%
                // We must match canvas coords
                const btnX = canvas.width * 0.85;
                const btnY = canvas.height * 0.25;
                const btnR = 70; // Match HTML visual size approx

                // Hands Indices
                const leftHand = landmarks[19]; // L Index
                const rightHand = landmarks[20]; // R Index

                if (!leftHand || !rightHand) return;

                const lx = leftHand.x * canvas.width;
                const ly = leftHand.y * canvas.height;
                const rx = rightHand.x * canvas.width;
                const ry = rightHand.y * canvas.height;

                const distL = Math.hypot(lx - btnX, ly - btnY);
                const distR = Math.hypot(rx - btnX, ry - btnY);

                // Both hands inside circle?
                let active = false;
                if (distL < btnR && distR < btnR) {
                    active = true;
                    this.gestureProgress++;
                    if (this.gestureProgress > this.gestureMax) {
                        this.gestureProgress = 0;
                        if (this.state === 'START') this.startGame();
                        else if (this.state === 'GAMEOVER') this.restartGame();
                    }
                } else {
                    this.gestureProgress = Math.max(0, this.gestureProgress - 5);
                }

                // UPDATE HTML UI
                if (active) {
                    els.gestureBtn.classList.add('active-pulse');
                } else {
                    els.gestureBtn.classList.remove('active-pulse');
                }

                // Draw Arc
                if (this.gestureProgress > 0) {
                    const ratio = this.gestureProgress / this.gestureMax;
                    const angle = ratio * Math.PI * 2;

                    // SVG Arc Path
                    // r=45, cx=50, cy=50
                    // Start at -90deg (top)
                    const r = 45;
                    const cx = 50;
                    const cy = 50;
                    const startX = cx;
                    const startY = cy - r;

                    // Calculate end point
                    // angle is radians clockwise from top if we adapt math, 
                    // but standard math is from right (0). Top is -PI/2.
                    const endAngle = -Math.PI / 2 + angle;
                    const endX = cx + r * Math.cos(endAngle);
                    const endY = cy + r * Math.sin(endAngle);

                    const largeArc = angle > Math.PI ? 1 : 0;

                    const d = `M ${startX} ${startY} A ${r} ${r} 0 ${largeArc} 1 ${endX} ${endY}`;
                    els.gestureProgressPath.setAttribute('d', d);
                } else {
                    els.gestureProgressPath.setAttribute('d', '');
                }
            }
        }

        const game = new Game();

        // --- NEW MEDIA PIPE SETUP (Largest Skeleton Priority) ---

        let poseLandmarker = undefined;
        let drawingUtils = undefined;
        let lastVideoTime = -1;
        let POSE_CONNECTIONS = null;
        let targetLandmarks = null; // PERSISTENT

        async function setupMediaPipe() {
            const { PoseLandmarker, FilesetResolver, DrawingUtils } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js");

            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );

            poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numPoses: 5, // Enable multi-pose detection
                minPoseDetectionConfidence: 0.5,
                minPosePresenceConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            drawingUtils = new DrawingUtils(ctx);
            POSE_CONNECTIONS = PoseLandmarker.POSE_CONNECTIONS;

            console.log("MediaPipe Pose Landmarker Loaded");
            enableWebcam();
        }

        function enableWebcam() {
            const constraints = { video: { width: 1280, height: 720 } };
            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    video.play();
                    requestAnimationFrame(gameLoop);
                });
            }).catch(err => {
                console.error("Camera access denied or failed:", err);
                alert("Camera access denied. Please allow camera access to play.");
            });
        }

        function gameLoop(timestamp) {
            try {
                if (video.videoWidth > 0 && (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight)) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // --- 1. Draw Mirrored Video ---
                ctx.save();
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);

                if (video.readyState >= 2) {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                }
                ctx.restore();

                // --- 2. Detect Pose ---
                if (poseLandmarker && video.currentTime !== lastVideoTime && video.videoWidth > 0) {
                    lastVideoTime = video.currentTime;
                    const result = poseLandmarker.detectForVideo(video, timestamp);

                    // --- LARGEST SKELETON PRIORITY LOGIC ---
                    if (result.landmarks && result.landmarks.length > 0) {
                        let maxArea = -1;
                        let maxIndex = -1;

                        for (let i = 0; i < result.landmarks.length; i++) {
                            const lm = result.landmarks[i];
                            let minX = 1, maxX = 0, minY = 1, maxY = 0;

                            // Calculate Bounding Box
                            for (let p of lm) {
                                if (p.x < minX) minX = p.x;
                                if (p.x > maxX) maxX = p.x;
                                if (p.y < minY) minY = p.y;
                                if (p.y > maxY) maxY = p.y;
                            }

                            const area = (maxX - minX) * (maxY - minY);
                            if (area > maxArea) {
                                maxArea = area;
                                maxIndex = i;
                            }
                        }

                        // Priority: Largest formatted skeleton
                        if (maxIndex !== -1) {
                            // FLIP X HERE!
                            const rawLandmarks = result.landmarks[maxIndex];
                            targetLandmarks = rawLandmarks.map(p => ({
                                ...p,
                                x: 1.0 - p.x,
                                visibility: p.visibility // Ensure visibility is copied
                            }));
                        }
                    } else {
                        targetLandmarks = null;
                    }
                }

                // --- 3. Draw Skeleton and Game (Normal Context) ---
                if (targetLandmarks && drawingUtils && POSE_CONNECTIONS) {
                    drawingUtils.drawConnectors(targetLandmarks, POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
                    drawingUtils.drawLandmarks(targetLandmarks, { color: '#FF0000', lineWidth: 2, radius: 3 });
                }

                game.draw(ctx, targetLandmarks);

                game.update(targetLandmarks);
                game.updateGestureLogic(targetLandmarks); // NEW

                requestAnimationFrame(gameLoop);
            } catch (err) {
                console.error("Game Loop Crash:", err);
                // Attempt restart loop? No, might infinite loop error.
            }
        }

        setupMediaPipe();
    </script>
</body>

</html>